env REDIS_HOST;
env REDIS_PORT;
env REDIS_DB;
env REDIS_PASSWORD;

daemon off;
user root;    # 设置nginx的启动用户

worker_processes  auto;        #nginx worker 数量
events {
    worker_connections 1024;
}


# error_log logs/error.log;   # 文件日志 #指定错误日志文件路径
error_log /dev/stdout; # Docker日志 # 重定向错误日志到标准输出

stream {
    ## TCP 代理日志格式定义
    log_format tcp_proxy '$remote_addr [$time_local] '
                         '$protocol $status $bytes_sent $bytes_received '
                         '$session_time "$upstream_addr" '
                         '"$upstream_bytes_sent" "$upstream_bytes_received" "$upstream_connect_time"';
    ## TCP 代理日志配置
    # Docker日志 # 重定向访问日志到标准输出
    access_log /dev/stdout tcp_proxy;
    # 文件日志 非调试时日志缓存
    # access_log logs/access.log tcp_proxy buffer=64k flush=1m;
    # 调试日志 调试时日志不缓存
    # access_log logs/access.log tcp_proxy;
    # open_log_file_cache off;

    resolver 119.29.29.29 ipv6=off;

#     lua_package_path '$prefixlua/?.lua;/blah/?.lua;;';
    # lua_code_cache off; # 仅调试时打开
    lua_code_cache on;

    ## TCP 代理配置
    upstream backend {
        server 127.0.0.2:30100;# 这里是占位用的，Nginx规定至少要有一个站点，实际是下面的lua调度，但调度失败时会使用，所以还是写个不通的ip
        balancer_by_lua_block {
            require("lua.proxy").balancer_by()
        }
    }

    lua_shared_dict white_ips 1m;

    init_worker_by_lua_block {
        require("lua.proxy").init_worker_by();
        require("lua.iputils").init_worker_by();
    }

    server {

        preread_by_lua_block {
            require("lua.iputils").check_white_ip(true);
            require("lua.proxy").preread_by();
        }
        # 下面是本机的端口，也就是爬虫固定写死的端口
        listen 0.0.0.0:30100;       #隧道代理，随机模式，代理列表索引=random(代理数)
        listen 0.0.0.0:30101-30200; #隧道代理，端口映射，代理列表索引=端口号%代理数
        proxy_connect_timeout 3s;
        proxy_timeout 15s;
        proxy_pass backend; #这里填写对端的地址
    }
}

http {
    # Docker日志 # 重定向访问日志到标准输出
    access_log /dev/stdout;

    # lua_code_cache off; # 仅调试时打开
    lua_code_cache on;

    resolver 119.29.29.29 ipv6=off;  # 解决resty.http库报错： null "no resolver defined to resolve
#    init_worker_by_lua_file lua/http_init_fecth.lua;
    init_worker_by_lua_block {
        require("lua.iputils").init_worker_by();
    }

#     init_by_lua_block {
#       local iputils = require("resty.iputils")
#       iputils.enable_lrucache()
#       local whitelist_ips = {
#           "127.0.0.1",
#           "10.10.10.0/24",
#           "192.168.0.0/16",
#           "172.18.0.0/24",
#       }
#
#       -- WARNING: Global variable, recommend this is cached at the module level
#       -- https://github.com/openresty/lua-nginx-module#data-sharing-within-an-nginx-worker
#       whitelist = iputils.parse_cidrs(whitelist_ips)
#     }

    access_by_lua_block {
        --local iputils = require("resty.iputils")
        --if not iputils.ip_in_cidrs(ngx.var.remote_addr, whitelist) then
        --  return ngx.exit(ngx.HTTP_FORBIDDEN)
        --end
        require("lua.iputils").check_white_ip()
    }

    server {
        listen 0.0.0.0:30000;

        location / {
            content_by_lua_block {
                ngx.print("Hello, world.");
            }
        }
        location /time {
            content_by_lua_block {
                ngx.print(ngx.time());
            }
        }
        location /time/now {
            content_by_lua_block {
                ngx.print(ngx.now()*1000);
            }
        }
        location /ip {
            content_by_lua_block {
                ngx.print(ngx.var.remote_addr);
            }
        }
        location /ip/proxy {
            # 输出3种可能的ip情况，以检测代理匿名度
            content_by_lua_block {
                local ips = {}
                if ngx.var.remote_addr then
                    table.insert(ips, ngx.var.remote_addr)
                end
                if ngx.var.http_via then
                    table.insert(ips, ngx.var.http_via)
                end
                if ngx.var.http_x_forwarded_for then
                    table.insert(ips, ngx.var.http_x_forwarded_for)
                end
                ngx.print(table.concat(ips, ','));
            }
        }
        location /proxy/del {
            content_by_lua_file lua/proxy_del.lua;
        }
        location /set {
            content_by_lua_block {
                local white_ips = ngx.shared.white_ips
                white_ips:set("Jim", 8)
                ngx.say("STORED")
            }
        }
        location /get {
            content_by_lua_block {
                -- local white_ips = ngx.shared.white_ips
                for idx, key in pairs(ngx.shared:get_keys()) do
                    ngx.say(idx, ":", ngx.shared:get(key), ":", type(key), ":", key)
                end
            }
        }
    }
}